<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Earth Defense Simulation</title>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
  </style>
</head>
<body>
<script>
let debrisList = [];
let laser, laserBeam = null, laserCooldown = 0;
let stars = [];
let earthImg;

function preload() {
  earthImg = loadImage("https://upload.wikimedia.org/wikipedia/commons/9/97/The_Earth_seen_from_Apollo_17.jpg");
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  angleMode(DEGREES);

  // background stars
  for (let i = 0; i < 500; i++) {
    stars.push(createVector(random(width), random(height)));
  }

  // debris orbiting Earth
  for (let i = 0; i < 25; i++) {
    debrisList.push(new Debris(random(120, 250), random(0, 360), random(0.2, 0.7)));
  }

  // laser gun at bottom
  laser = new Laser(width / 2, height - 50, 300);
}

function draw() {
  background(0);

  drawStars();
  drawEarth();

  // debris
  for (let d of debrisList) { d.update(); d.show(); }

  // Auto-fire logic
  if (laserCooldown === 0) {
    let targets = laser.findTargets(debrisList);
    if (targets.length > 0) {
      laser.fire(targets[0]);
      laserCooldown = 60; // cooldown frames
    }
  }

  // laser
  laser.update();
  laser.show();

  // beam
  if (laserBeam) {
    laserBeam.show();
    if (laserBeam.lifetime <= 0) laserBeam = null;
    else laserBeam.lifetime--;
  }

  if (laserCooldown > 0) laserCooldown--;
}

// === Helpers ===
function drawStars() {
  noStroke();
  for (let s of stars) {
    let flicker = random(150, 255);
    fill(255, flicker);
    ellipse(s.x, s.y, 2);
  }
}

function drawEarth() {
  push();
  imageMode(CENTER);
  translate(width / 2, height / 2);
  image(earthImg, 0, 0, 250, 250);
  pop();
}

// === Classes ===
class Debris {
  constructor(radius, angle, speed) {
    this.radius=radius; this.angle=angle; this.speed=speed;
    this.destroyed=false; this.sparks=[];
  }
  update(){
    if(!this.destroyed) this.angle+=this.speed;
    else{ for(let s of this.sparks) s.update(); this.sparks=this.sparks.filter(s=>!s.dead()); }
  }
  getPosition(){
    let x=width/2 + this.radius*cos(this.angle);
    let y=height/2 + this.radius*sin(this.angle);
    return createVector(x,y);
  }
  show(){
    let pos=this.getPosition();
    if(!this.destroyed){ fill(255,100,100); noStroke(); ellipse(pos.x,pos.y,10,10); }
    else{ for(let s of this.sparks) s.show(); }
  }
  destroy(){
    this.destroyed=true;
    let pos=this.getPosition();
    for(let i=0;i<15;i++) this.sparks.push(new Spark(pos.x,pos.y));
  }
}

class Laser {
  constructor(x,y,range){ this.pos=createVector(x,y); this.range=range; this.angle=-90; this.targetAngle=this.angle; }
  update(){ this.angle=lerpAngle(this.angle,this.targetAngle,0.1); }
  
  // Auto-target function
  findTargets(debrisList){
    let inRange=debrisList.filter(d=>!d.destroyed && dist(this.pos.x,this.pos.y,d.getPosition().x,d.getPosition().y)<=this.range);
    if(inRange.length>0){
      // Find closest debris
      let closest=inRange[0]; 
      let minDist=dist(this.pos.x,this.pos.y,closest.getPosition().x,closest.getPosition().y);
      for(let d of inRange){ 
        let distD=dist(this.pos.x,this.pos.y,d.getPosition().x,d.getPosition().y); 
        if(distD<minDist){ closest=d; minDist=distD; } 
      }
      let targetPos=closest.getPosition();
      this.targetAngle=degrees(atan2(targetPos.y-this.pos.y,targetPos.x-this.pos.x));
      return [closest];
    } else { 
      this.targetAngle=-90; 
      return []; 
    }
  }
  
  fire(target){ 
    let tPos=target.getPosition(); 
    laserBeam=new Beam(this.pos,tPos); 
    target.destroy(); 
  }
  
  show(){
    push(); translate(this.pos.x,this.pos.y); rotate(this.angle);
    fill(50); rectMode(CENTER); rect(0,0,60,20);
    fill(0,200,0); rect(30,0,40,10);
    fill(0,255,0); ellipse(50,0,20,20);
    pop();
    noFill(); stroke(0,150,0,50); ellipse(this.pos.x,this.pos.y,this.range*2);
  }
}

class Beam {
  constructor(start,target){ this.start=start.copy(); this.end=target.copy(); this.lifetime=10; }
  show(){ strokeWeight(4); stroke(0,255,0,200); line(this.start.x,this.start.y,this.end.x,this.end.y); }
}

class Spark {
  constructor(x,y){ this.pos=createVector(x,y); this.vel=p5.Vector.random2D().mult(random(1,3)); this.alpha=255; this.size=random(2,4); }
  update(){ this.pos.add(this.vel); this.alpha-=15; this.size*=0.9; }
  show(){ noStroke(); fill(255,150,0,this.alpha); ellipse(this.pos.x,this.pos.y,this.size); }
  dead(){ return this.alpha<=0||this.size<0.1; }
}

function lerpAngle(a,b,t){ let diff=b-a; if(diff>180) diff-=360; else if(diff<-180) diff+=360; return a+diff*t; }
function windowResized(){ resizeCanvas(windowWidth,windowHeight); }
</script>
</body>
</html>
